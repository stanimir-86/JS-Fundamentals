//RegexP ни дават шаблон по,който да търсим strings в текст.
//Пример да подавам услвовие да ми търси в текс "is",без значение дали е с малка буква или не.
//Създаване на регекс в сайта,е като се попълни pattern.
//Специален символ е |-or(или).Трябва да подавам точен текст без допълнително място или друг символ
//тогава се променя условието
//абц|def търсене в текст- abc dhhd def
//Специален символ .(който означава всеки символ,дали текст или знак)
//Пример def.  и ако търся в текст defs-ще има съвпадени,както и def1,def! и тн..
//но ако е на нов ред няма да има съвпадение.съвпада с произволен знак (с изключение на терминатори на редове)"\n"
//Специален символ ^ потвърждава позиция на търсене в началото на ред
//Пример ^def-означава,че това което търся трябва да е в началото на стринга
//текст-def12423-ще го намери,но ако има всякакъв символ пред def няма да го намери
//Специален символ $-същото но за търсена в края на стринга.
//Мога да комбинирам и двата символ ^def$-което е за търсене на конкретен стринг без други символи
//Пример текст def1 s патерн ^def$-няма съвпадение,но ако е def ще има
// Специален символ \(escape) това означава,че ако подам специален символ след него,той няма да бъде такъв
//пример \$100-pattern и търси в текст $100-ще има съвпадение,защото съм сложил в началото \
//Специален символ []-всеки символ подаден в [] ще бъде мачнат.Това е запис за търсене на множество.
//мога да подам диапазон [a-z]-проверява всички малки символи от ASCI таблицата
//диапазона е с нарастване ,не може да е обратната[z-a]-грешка
//изброяване на два или повече диапазона[a-zA-Z]
//отрицание в множествот се прави с^ или [^ab]-намери ми всико,което не е ab
//Готови множества,които имаме в regex:
//\w-всички символи от малки букви,Големи букви ,числа и долна черта или [a-zA-Z0-9_]
//|W ако подам така с главна буква е еквивалент на отрицание или [^a-zA-Z0-9_]
//\s-хваща всички празни символи-white space
//\S- отрицание за всички ,които не са.
//\d-множество за числа от 0-9 или [0-9]
//\D всичко което не е цифра
//\b хвани ми където думата приключва и започва новата или (^\w|\w$|\W\w|\w\W)
//\B отрицание
//quantifiers
//текс който да търси avc* и така ще търси последния символ 0 или повече пъти
//пример av-ще го мачне,защото имаме 0 пъти c и avccccc пак е правилно
//мога да огранича мачването с avc*? и това ще ми мачне до av или 0 за c
//сам по себе си ? също е quantifier и означава мачвай 0 или веднъж avc
//също мога да го огранича avc?? така и ще ми мачне само av без c
//quantifier + тук символа avc+ трябва да го има поне веднъж ,за да го мачне и нагоре.
//quantifier е avc{2}-точно колко мача искам да хвана
//мога да му създам диапозн с втори пармаетър avcccc{2,3} и ще мачне до 3-тото c
//отново мога и avcccc{2,3}?къде ще мачне avcc
//avcccc{2,} така ще мачва миниму 2 пъти и нагоре без ограничение
//мога да го направя и с множество [a-z]+
//captures grous ()-часта от паттерна ,която съм сложил в () е важна за мен.
//пример:
//[a-z]+\.([a-z]+)\.bg и текст за мачване admin.(softuni).bg
// като softuni мога да си го извадя в променлива и да си го ползвам.
//(?:)-none capturing group това е група,която резултата не ми трябва.Тя участва като вътршна група от друга,която да ни послужи за нещо
//мога да си наименовам групите
//пример:
//(?<mytext>(?:abc)*) с текст за търсене abcabcabc
//има мач на текста ,но и има група резултат с mytext